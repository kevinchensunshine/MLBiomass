/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var data = /* color: #d63000 */ee.Geometry.MultiPoint(
        [[9.654077535308149, 56.47565754633838],
         [9.540094381011274, 56.5805585028823]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
var gpp_utils = require('users/kevinlc3/ndvi_nir_collection:Utils/GPP_Processing_Lib');
var bands = ['NIRVP_0000', 'NIRVP_0300', 'NIRVP_0600', 'NIRVP_0900', 'NIRVP_1200', 'NIRVP_1500', 'NIRVP_1800', 'NIRVP_2100'];

//##############################################################
// Step-1: Prepare a NDVI time-series
//##############################################################
var point = data.first()
var geometry = point.geometry();
var bufferDistance = 5000; // Buffer in meters, adjust as needed
var clippingRegion = geometry.buffer(bufferDistance);
var bands = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B8A', 'B11', 'B12'];
// Function to clip the image to the defined geometry
function clipToRegion(image) {
  return image.clip(clippingRegion);
}

var styling = {color:'red',fillColor:'00000000'}
Map.addLayer(geometry, {color: 'red'}, 'ROI');
Map.centerObject(geometry, 15)
// var geometry = geometry.geometry()
var startDate_one = ee.Date('2018-09-01')
var endDate_one = ee.Date('2018-12-31')

var filtered_one = s2
  .filter(ee.Filter.date(startDate_one, endDate_one))
  .filter(ee.Filter.bounds(geometry))

function maskS2clouds(image) {
  var qa = image.select('QA60');
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
            .and(qa.bitwiseAnd(cirrusBitMask).eq(0));
  return image.updateMask(mask).divide(10000)
              .copyProperties(image, ['system:time_start','system:time_end']);
}

function addNDVI(image) {
  // Compute NDVI
  var ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI');
  // Add NIRv as a new band to the image
  return image.addBands(ndvi);
}

var filtered_one = filtered_one.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)).map(maskS2clouds).map(addNDVI)
var filtered_s2images = filtered_one.select('NDVI');

print('Original Collection', filtered_s2images)

//##############################################################
// Step-2: Create an empty Time-Series with images at n days
//##############################################################

// Select the interval. We will have 1 image every n days
var n = 1;
var totalDays = endDate_one.difference(startDate_one, 'day');
var daysToInterpolate = ee.List.sequence(1, totalDays, n);

var initImages = daysToInterpolate.map(function(day) {
  var image = ee.Image().rename('NDVI').toFloat().set({
    'system:index': ee.Number(day).format('%d'),
    'system:time_start': startDate_one.advance(day, 'day').millis(),
    'type': 'interpolated'
  })
  return image
})

var initCol = ee.ImageCollection.fromImages(initImages);
print('Empty Collection with Bands', initCol);

//##############################################################
// Step-3: Use Joins to find before/after images
//##############################################################

// Merge empty collection with the original collection so we can
// find images to interpolate from
var mergedCol = filtered_s2images.merge(initCol)

var mergedCol = mergedCol.map(function(image) {
  var timeImage = image.metadata('system:time_start').rename('timestamp')
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))
  return image.addBands(timeImageMasked)
})

// Specify the time-window
// Set it so that we have at least 1 non-cloudy image in the period
var days = 100
var millis = ee.Number(days).multiply(1000*60*60*24)

var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

var lessEqFilter = ee.Filter.lessThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})


var greaterEqFilter = ee.Filter.greaterThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})


var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
var join1 = ee.Join.saveAll({
  matchesKey: 'after',
  ordering: 'system:time_start',
  ascending: false})
  
var join1Result = join1.apply({
  primary: mergedCol,
  secondary: mergedCol,
  condition: filter1
})

var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)

var join2 = ee.Join.saveAll({
  matchesKey: 'before',
  ordering: 'system:time_start',
  ascending: true})
  
var join2Result = join2.apply({
  primary: join1Result,
  secondary: join1Result,
  condition: filter2
})

//##############################################################
// Step-4: Apply linear interpolation to fill each image
//##############################################################

// Once the joins are done, we don't need original NDVI images
// We keep only the blank images which now have matching NDVI images
// as properties
// Filter out only the interpolated images
var filtered = join2Result.filter(ee.Filter.eq('type', 'interpolated'));

function interpolateImages(image) {
  image = ee.Image(image)

  var beforeImages = ee.List(image.get('before'))
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
  var afterImages = ee.List(image.get('after'))
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

  var t1 = beforeMosaic.select('timestamp').rename('t1')
  var t2 = afterMosaic.select('timestamp').rename('t2')

  var t = image.metadata('system:time_start').rename('t')

  var timeImage = ee.Image.cat([t1, t2, t])

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })

  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
  var result = image.unmask(interpolated)
  return result.copyProperties(image, ['system:time_start'])
}

var interpolatedCol = ee.ImageCollection(
  filtered.map(interpolateImages)).select('NDVI')
print('Interpolated Collection', interpolatedCol.first())



//##############################################################
// Step-5: Apply Savitzky-Golay filter
//##############################################################

var oeel=require('users/OEEL/lib:loadAll');
// https://www.open-geocomputing.org/OpenEarthEngineLibrary/#.ImageCollection.SavatskyGolayFilter

// Use the same maxDiffFilter we used earlier
var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// Use the default distanceFunction
var distanceFunction = function(infromedImage, estimationImage) {
  return ee.Image.constant(
      ee.Number(infromedImage.get('system:time_start'))
      .subtract(
        ee.Number(estimationImage.get('system:time_start')))
        );
  }

// Apply smoothing of order=5
var order = 5;
var smoothed = oeel.ImageCollection.SavatskyGolayFilter(
  interpolatedCol, 
  maxDiffFilter,
  distanceFunction,
  order)

// Select the d_0_ndvi band and rename it
var smoothed = smoothed.select(['d_0_NDVI'], ['smoothed_NDVI'])
print('smoothed_first', smoothed.first())
//##############################################################
// Step-6: Visualize the results
//##############################################################
function formatDate(feature) {
  return ee.Date(feature.get('system:time_start')).format('YYYY-MM-dd');
}

function reduceImage1(image) {
  var meanNdvi = image.reduceRegion({
    reducer: ee.Reducer.mean(),
    geometry: geometry,
    scale: 10,
    maxPixels: 1e9
  }).get('NDVI');

  // Get the time_start from the image metadata
  var timeStart = image.get('system:time_start');

  return ee.Feature(null, {'meanNDVI': meanNdvi, 'system:time_start': timeStart});
}

function reduceImage2(image) {
  var meanNdvi = image.reduceRegion({
    reducer: ee.Reducer.mean(),
    geometry: geometry,
    scale: 10,
    maxPixels: 1e9
  }).get('smoothed_NDVI');

  // Get the time_start from the image metadata
  var timeStart = image.get('system:time_start');

  // Return a feature with mean NDVI and time_start property
  return ee.Feature(null, {'smoothed_NDVI': meanNdvi, 'system:time_start': timeStart});
}

var reducedNdviCol = filtered_s2images.map(reduceImage1).map(function(feature) {
  return feature.set('date', formatDate(feature));
})
print(reducedNdviCol)
// Apply the function to each image in the smoothed collection
var reducedSmoothed = smoothed.map(reduceImage2).map(function(feature) {
  return feature.set('date', formatDate(feature));
})
print(reducedSmoothed)

// Export the original NDVI data
Export.table.toDrive({
  collection: reducedNdviCol,
  description: 'Original_NDVI_season',
  fileFormat: 'CSV',
  folder: 'earthengine',
  selectors: ['meanNDVI', 'date'] // Specify the properties to export
});

// Export the smoothed NDVI data
Export.table.toDrive({
  collection: reducedSmoothed,
  description: 'Smoothed_NDVI_season',
  fileFormat: 'CSV',
  folder: 'earthengine',
  selectors: ['smoothed_NDVI', 'date'] // Specify the properties to export
});